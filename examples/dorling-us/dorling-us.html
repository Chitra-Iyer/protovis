<html>
  <head>
    <title>Dorling Cartogram</title>
    <link type="text/css" rel="stylesheet" href="../ex.css?3.1"/>
    <script type="text/javascript" src="../../protovis-d3.2.js"></script>
    <script type="text/javascript" src="us_lowres.js"></script>
    <script type="text/javascript" src="us_stats.js"></script>
    <script type="text/javascript" src="us_borders.js"></script>
    <style type="text/css">
      body {
        margin: 0;
      }

      #fig {
        width: 640px;
        height: 400px;
      }
    </style>
  </head>
  <body><div id="center"><div id="fig">
    <script type="text/javascript+protovis">
  function area(pts) {
     var area=0;
     var nPts = pts.length;
     var j=nPts-1;
     var p1; var p2;

     for (var i=0;i<nPts;j=i++) {
        p1=pts[i]; p2=pts[j];
        area+=p1.x*p2.y;
        area-=p1.y*p2.x;
     }
     area/=2;
     return area;
  }

  function centroid(pts) {
     var nPts = pts.length;
     var x=0; var y=0;
     var f;
     var j=nPts-1;
     var p1; var p2;

     for (var i=0;i<nPts;j=i++) {
        p1=pts[i]; p2=pts[j];
        f=p1.x*p2.y-p2.x*p1.y;
        x+=(p1.x+p2.x)*f;
        y+=(p1.y+p2.y)*f;
     }

     f=area(pts)*6;
     return {x:x/f, y:y/f};
  }

  geography.forEach(function(c) {
    c.code = c.code.toUpperCase();
    if(!c.borders) alert(c.code);
    c.center = centroid(c.borders[0].map(function(p) { return {x:p[0], y:p[1]}} ));
  });

var i = 0,
    w = 640,
    h = 400,
    scale = pv.Scale.geo({lon:-130, lat:20}, {lon:-62, lat:54}).projection("none").range({x:0, y:0}, {x:w, y:h});
    nodes = [];
    codeToNode = [];
    links = [];
    geography.forEach(function(s) {
      if(us_stats[s.code]) {
        var c = {lon:s.center.x, lat:s.center.y};
            x = scale(c).x,
            y = scale(c).y,
            //r = Math.sqrt(us_stats[s.code].pop)*us_stats[s.code].obese/100 /25;
            r = Math.sqrt(us_stats[s.code].land)*us_stats[s.code].obese/100 /4;
            n = {x: x, y: y, p: {x: x, y: y}, r: r, code:s.code};
        nodes.push(n);
        codeToNode[s.code] = n;
      }
    });
    geography.forEach(function(s) {
      if(us_stats[s.code]) {
        var borders = us_borders[s.code];
        borders.forEach(function(b) {
          if(codeToNode[s.code] && codeToNode[b] && s.code < b) {
              var nodeA = codeToNode[s.code];
              var nodeB = codeToNode[b];
              links.push({sourceNode:nodeA, targetNode:nodeB, length:(nodeA.r + nodeB.r)});
          }
        });
      }
    });

var collisionConstraint = pv.Constraint.collision(function(d) d.r),
    positionConstraint = pv.Constraint.position(function(d) d.p),
    linkConstraint = pv.Constraint.link(100).links(links);

var sim = pv.simulation(nodes)
    .constraint(collisionConstraint)
    .constraint(positionConstraint)
    .constraint(linkConstraint)
    .force(pv.Force.drag());

var vis = new pv.Panel()
    .width(w)
    .height(h)
    .event("mousedown", pv.Behavior.pan())
    .event("mousewheel", pv.Behavior.zoom())
    .fillStyle("white");

/*
vis.add(pv.Dot)
    .data(nodes)
    .left(function(d) d.p.x)
    .top(function(d) d.p.y)
    .fillStyle("brown")
    .strokeStyle(null);

vis.add(pv.Panel)
    .data(nodes)
  .add(pv.Line)
    .data(function(d) [d, d.p])
    .left(function(d) d.x)
    .top(function(d) d.y)
    .strokeStyle("brown");
*/

vis.add(pv.Dot)
    .data(nodes)
    .left(function(d) d.x)
    .top(function(d) d.y)
    .radius(function(d) d.r)
    .fillStyle(pv.color("steelblue").alpha(.8))
    .strokeStyle("black")
   .add(pv.Label)
    .text(function(d) d.code)
    .textAlign("center")
    .textBaseline("middle");

var timer = setInterval(function() {
    if (i++ > 150) clearInterval(timer);
    sim.step();
    positionConstraint.alpha(Math.pow(.7, i + 10) + .03);
    linkConstraint.alpha(Math.pow(.9, i + 10) + .01);
    vis.render();
  }, 42);

    </script>
  </div></div></body>
</html>
